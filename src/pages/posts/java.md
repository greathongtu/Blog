---
layout: '../../layouts/MarkdownPost.astro'
title: 'Java 学习'
pubDate: 2023-04-08
description: '学习Jvm 等知识总结'
author: 'Aaron'
cover:
    url: '/preview/javapic.png'
    alt: 'cover'
tags: ["Java", "Jvm"]
theme: 'light'
featured: false
---

# JVM 内存模型

referen： https://pdai.tech/md/java/jvm/java-jvm-struct.html

方法区， 堆， 虚拟机栈， PC， 本地方法栈。

常量池在方法区里，jdk 8 之前方法区在堆中，之后在本地内存中。

在HotSpot虚拟机的实现中，虚拟机栈和本地方法栈的功能合并在一起，统一为Java栈。

## 记忆集（Remembered Set）卡表 Card Table
在Java中，垃圾收集器（GC）用于自动回收不再使用的对象，从而释放内存。在进行垃圾收集时，GC需要扫描所有的GC Roots（根集合）来确定哪些对象是可达的。可达对象是指在根集合中或可由根集合中的对象引用的对象。扫描范围较大会导致垃圾收集的性能降低。为了缩减GC Roots扫描范围，可以使用记忆集（Remembered Set）。

记忆集是一种用于记录跨代引用信息的数据结构。在分代收集的GC算法中，Java堆被分为年轻代（Young Generation）和老年代（Old Generation）。年轻代中的对象经常被回收，而老年代中的对象回收较少。这种情况下，可以使用记忆集来跟踪老年代中的对象引用年轻代中的对象。这样，当执行年轻代的垃圾收集时，GC只需要扫描记忆集而不是整个老年代，从而缩减了GC Roots扫描范围。会用到写屏障。

## 三色标记法

并发的时候会有问题。
当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：
·赋值器插入了一条或多条从黑色对象到白色对象的新引用；
·赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

解决办法：`增量更新`（Incremental Update）和`原始快照`（Snapshot At The Beginning，SATB）

## 经典垃圾收集器
* Serial收集器：新生代收集器基于标记-复制算法实现，老生代收集器基于标记-整理算法实现。单线程，执行垃圾收集之前需要Stop the world。优点是占用内存少，单线程效率高。适合CPU核心少的计算机使用。

* ParNew收集器：Serial收集器的多线程版本，同样执行垃圾收集之前需要Stop the world。ParNew的高光是CMS指定的新生代收集器（CMS只能作用在老年代）。

* Parallel Scavenge收集器：新生代收集器，基于标记-复制算法实现。支持多线程，Stop the world。Parallel Scavenge的设计目标是极大化回收对象和分配对象的吞吐量（所以延迟就很高）。

* Serial Old收集器：Serial收集器的老年代版本，基于标记-整理算法。

* Parallel Old收集器：Parallel Scavenge收集器的老年代版本，基于标记-整理算法。

* CMS收集器：CMS全称Concurrent Mark Sweep，基于标记-清理算法，支持多线程，可以与用户线程并行。其分为四个阶段，第一个和第三个阶段需要Stop the world。CMS的有点是延迟低，且最耗时的两个过程支持与用户线程并行。缺点是由于需要与用户线程并行，因此不能等到老年代满了才开始垃圾回收（可能用户垃圾回收需要内存被用户线程抢占完了），默认老年代花费了68%的内存就会被激活，这样会导致可能执行了非必要的GC，我们可以选择提高触发的比例阈值，但是这时候如果CMS收集器无法分配到足够的内存，就会发生并发失败，而临时启用Serial Old收集器来重新进行老年代的回收。还有一个缺点就是由于基于标记-清理算法，所以会产生很多内存碎片，一种解决方案是执行若干次垃圾回收后，执行一次Full GC减少内存碎片。
    * 初始化标记
    * 并发标记
    * 重新标记
    * 并发清除

* G1收集器（Garbage first）：G1收集器目的是建立起“停顿时间模型”的收集器。停顿时间模型的含义是指在长度为M
的时间中，消耗在垃圾收集上的时间大概率不超过N。G1收集器将整个Java堆分成若干个小的Region，每个Region都的角色可以是Eden空间、Survivor空间或老年代空间。同时还有一个特殊的Humongous区域，用于存储大对象，如果一个对象占用空间比一个Region都大，它就会直接进入Humongous区域，并且G1大多数行为会将Humongous作为老年代处理。G1回收器每次执行时会根据内部计算的权值挑选权值最大的部分Region进行回收。但是由于每个Region都需要维护其余Region是否引用了这个Region中的对象，因此每个Region都有独立的卡表，这导致G1收集器会占用非常多的内存（一般是堆大小的10%~20%）。G1支持在没有Stop the world的情况下完成标记工作，其采用的解决冲突的算法是原始快照。但是G1收集器没有支持与用户线程并行完成清理工作，因为一次性只回收一部分的Region，时间一般是可控的。G1实现的是标记复制算法，每次回收的时候都会将被回收Region中的存活对象拷贝到其余的空的Region中。G1垃圾回收的过程如下：
    * 初始化标记
    * 并发标记
    * 最终标记
    * 筛选回收

*Shenandoah收集器：类似于G1收集器，但是Shenandoah支持与用户线程并发的清理过程，其次Shenandoah默认不适用分代收集，并且Shenandoah摒弃了为每个Region维护记忆集，转而使用连接矩阵的全局数据结构来记录Region的引用关系。由于Shenandoah使用的也是标记-复制技术，且由于清理过程是与用户线程同时进行的，那么如何实现的并发呢。Shenandoah使用了Brooks Pointer，一种类似于句柄的技术。其实现是在每个对象的头部增加一个转发指针，默认指向自己。并且为了避免在复制的过程中用户的写入操作，Shenandoah使用了CAS来实现所有对转发指针的访问必须同步执行，而这部分的功能也是通过读写屏障实现的。Shenandoah收集器的优势是暂停时间相对较短。

* ZGC收集器：目标与Shenandoah收集器类似，希望实现低暂停时间。ZGC的Region称为ZPage，具有动态创建、销毁和扩容的能力，容量分成小（容量2M，对象大小不能超过256KB）中（容量32M，对象大小不超过4MB）大（容量不固定，可以动态变化）。对对象进行标记，需要额外的空间，一般收集器使用对象头的空间，而G1、Shenandoah使用BitMap数据结构，而ZGC使用的是引用对象的指针上的空间。64位机器上，指针的真正可用空间是46位，ZGC占用了46位中的前4位实现标记，一位记录是否只能通过finalize方法才能被访问到，一位记录是否进入了重分配集，两位记录对象的三色标记。也因此ZGC只支持64位机器。ZGC没有使用Brooks Pointer，而是为每个Region都维护了一个转发表。ZGC中引用具有自愈特性，每次使用某个引用访问的时候，在读屏障中会将引用更新到最新（ZGC目前仅使用了读屏障），很显然只有第一次访问的时候会显著变慢，后面的访问是非常快的。并且ZGC不需要等待清理过程结束，就可以将那些所有存活对象都已经被复制走的Region进行复用（Shenandoah、G1收集器需要等待修复引用完成后才行），于是ZGC更难遇到内存不足的情况（理论上只要有一个空的Region可用，复制就可以继续下去），当然这里还是需要保留原来Region的转发表的。由于ZGC中的指针具有自愈能力，且转发表直到下一次GC发生前都是可以保留的，因此ZGC实际上并不会更新所有引用，而是在下一次GC的并发标记阶段，顺带修复所有引用，之后每个Region的转发表就可以释放了。

* Epsilon收集器：Epsilon收集器是一个不会进行垃圾回收的收集器，其仅有分配和管理内存的能力。Epsilon收集器适合那些生命周期非常短的应用（在堆耗尽之前就退出了）。


reference: https://juejin.cn/post/6844904039994359821

## Java 多态
c++的多态是通过每个对象的vptr 找到类的 vtable实现。

Java 也类似。当Java类（尤其是涉及继承和接口的类）被加载到JVM（Java虚拟机）中时，JVM会为每个类创建一个方法表。方法表包含了该类的所有方法的指针。

虚拟机在处理多态时，会通过对象的引用找到其对应的类，并从类的方法表中查找要调用的方法。
对象通过16个字节的对象头（包括class 指针和 Mark Word：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）中8个字节的class地址找到 object.class (类对象)，再通过指针找到本地内存（metaspace）中的 instanceKlass（一个表示类的元数据的结构，它包含了类的所有相关信息，包括字段、方法、常量池等。而 static 对象是和类对象在一起的，也就是堆中，JDK6之前是存在方法区的），这里有 _vtable 虚方法表

## 类加载器
能够通过一个类的全限定名来获取描述该类的二进制字节流的工具称为类加载器。每一个类加载器都拥有一个独立的类名空间，因此对于任意一个类，都必须由加载它的类加载器和这个类本身来共同确立其在 Java 虚拟机中的唯一性。这意味着要想比较两个类是否相等，必须在同一类加载器加载的前提下；如果两个类的类加载器不同，则它们一定不相等。

## 类的加载 & Class 对象
在Java中有两种对象：Class对象和实例对象，实例对象是类的实例，通常是通过new关键字构建的。Class对象是JVM生成用来保存对象的类的信息的。Java程序执行之前需要经过`编译`、`加载`、`链接`和`初始化`这几个阶段.

* 编译阶段会将源码文件编译为.class字节码文件，编译器同时会在.class文件中生成Class对象.

* 加载阶段通过JVM内部的类加载机制，将Class对象加载到内存中。虚拟机外部的二进制字节流会按照虚拟机所需的格式存储在方法区之中。（在创建对象实例之前，JVM会先检查Class对象是否在内存中存在，如果不存在，则加载Class对象，然后再创建对象实例，如果存在，则直接根据Class对象创建对象实例。）

* 链接包含验证、准备（内存）、解析（把类中的符号引用转换为直接引用）几个阶段。

* 初始化：为类的静态变量赋予正确的初始值。只有当对类的主动使用的时候才会导致类的初始化

* 最后还有使用和卸载

## 热点探测
即时编译器编译的目标是 “热点代码”，判断某段代码是否是热点代码的行为称为 “热点探测” （Hot Spot Code Detection），主流的热点探测方法有以下两种：

* 基于采样的热点探测 (Sample Based Hot Spot Code Detection)：采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那么就认为它是 “热点方法”。
* 基于计数的热点探测 (Counter Based Hot Spot Code Detection)：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是 “热点方法”。

# 代码优化
即时编译器除了将字节码编译为本地机器码外，还会对代码进行一定程度的优化，它包含多达几十种优化技术，这里选取其中代表性的四种进行介绍：

## 方法内联
最重要的优化手段，它会将目标方法中的代码原封不动地 “复制” 到发起调用的方法之中，避免发生真实的方法调用，并采用名为类型继承关系分析（Class Hierarchy Analysis，CHA）的技术来解决虚方法（Java 语言中默认的实例方法都是虚方法）的内联问题。

## 逃逸分析
逃逸行为主要分为以下两类：

* 方法逃逸：当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，此时称为方法逃逸；
* 线程逃逸：当一个对象在方法里面被定义后，它可能被外部线程所访问，例如赋值给可以在其他线程中访问的实例变量，此时称为线程，其逃逸程度高于方法逃逸。

如果能证明一个对象不会逃逸到方法或线程之外，或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可以为这个对象实例采取不同程序的优化：

* 栈上分配 (Stack Allocations)：如果一个对象不会逃逸到线程外，那么将会在栈上分配内存来创建这个对象，而不是 Java 堆上，此时对象所占用的内存空间就会随着栈帧的出栈而销毁，从而可以减轻垃圾回收的压力。

* 标量替换 (Scalar Replacement)：如果一个数据已经无法再分解成为更小的数据类型，那么这些数据就称为标量（如 int、long 等数值类型及 reference 类型等）；反之，如果一个数据可以继续分解，那它就被称为聚合量（如对象）。如果一个对象不会逃逸外方法外，那么就可以将其改为直接创建若干个被这个方法使用的成员变量来替代，从而减少内存占用。

* 同步消除 (Synchronization Elimination)：如果一个变量不会逃逸出线程，那么对这个变量实施的同步措施就可以消除掉。


## 公共子表达式消除
如果一个表达式 E 之前已经被计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生过变化，那么 E 这次的出现就称为公共子表达式。对于这种表达式，无需再重新进行计算，只需要直接使用前面的计算结果即可。

## 数组边界检查消除

对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的上下文检查以避免访问越界。如果数组的访问发生在循环之中，并且使用循环变量来访问数据，即循环变量的取值永远在 [0，list.length) 之间，那么此时就可以消除整个循环的数据边界检查，从而避免多次无用的判断。


# JMM 内存模型

* 原子性 synchronized
* 可见性 volatile
* 有序性 volatile

## CAS
需要结合 volatile 使用。实现无锁并发。适用于不激烈、多核CPU的情况。
CAS 属于乐观锁，synchronized 属于悲观锁

## synchronized

轻量级锁：虽然多线程，但是时间是错开的。
    加锁步骤：尝试跟锁定对象的 Mark Word 互换，成功的话就是轻量级锁。可以锁重入。解锁的话就是把 Mark Word 还回去，00 -> 01 （轻量级锁 -> 无锁）。如果失败的话升级为重量级锁，获取monitor （10）

重量级锁优化：自旋。

轻量级锁锁重入的优化：偏向锁：不需要多余的 CAS。第一次CAS 将线程ID 设置到对象的 Mark Word 中。之后发现是自己就表示没有竞争，不用重新CAS

